# Moving Away From React

> well, kind of

### What Do I Mean?

I'm moving away from building web applications in React to something more simple and lightweight.

To give some background, I started programming C in university then moved onto learning Python, forced to do Java, finally learned JavaScript, and have been writing TypeScript for quite some time now. Although I have been learning Rust for the past couple of months and I'm enjoying it **a lot**. I started to write more and more projects that targeted the web and to do this, I started writing React. Why did I choose it? You could say it was ignorance but honestly, it's what everyone I saw use and after using it I fell in love and did _everything_ in React. I think this was the first mistake I made which was not learning the _reasons_ why React was even made in the first place. What problems was it solving and were those problems something I was running into (**spoiler**: they weren't). Remember, this library was created by Meta, a company who thought they needed a better solution to drive high user interactivity on their platform. Meanwhile, I was just learning how to program and dove head first into it thinking it was what I needed to build frontends. Now that I think about it, I was super naive and know that the first thing that popped into my head when thinking about frontend development was **_REACT_**. I didn't fully understand the pros/cons of using an SPA framework and moreover, didn't understand the history of the web and how it evolved over time which would have given me more insight. Now I'm reflecting on those decisions and want to explain where my mind is at.

### SPA, MPA, SSR, CSR, WTF?

I'm not sure what power trip the web guys were on when forming all these acronyms but either ways they are important to understand. What I was doing by using React in my next side project that consisted of no more than a few CRUD functionalities was delivering a massive JavaScript bundle to the client on first page load. Along with this, I was making SEO a pain as my web application had no semantic HTML tags, just one div that was injected by all my JavaScript code. By definition, this is what an SPA (Single Page Application) does, and even though it sounds bad, it actually brought a huge benefit when it came to client side interactivity. I was able to code complex logic in my UI and not rely on a server to return the state of the application which would require a full page reload (yikes). In fact, I convinced myself that the MPA was undesirable due to the limitations and reliance on a server and in part it made sense. Even though my projects at the time were simple CRUD apps, the thought of a full page reload when clicking "done" on my todo list item or when searching in a text box was frightening. Now obviously you can achieve these things by writing some client side JavaScript but doing DOM manipulations manually seemed archaic and unnecessary. I was on the SPA CSR train and because of my lack of knowledge and stubbornness, I continued on.

Around this time, I was introduced to Next.js and this time, tried to understand the problem it was solving. Basically the pain points of an SPA I mentioned above by serving a middleman or BFF (backend for frontend) that served HTML and worked nicely with React. It also provided the developer with a bunch of nice to haves like an optimized `Image` tag, a productive DX, and overall felt like the solution we needed from the pitfalls of a standalone SPA. It made a lot of sense to me and I adopted it very quickly. Wait, not everyone writes React code right? How do other tech stacks like Ruby or Elixir solve this issue? Well, they created [Hotwire](https://hotwired.dev/) and [LiveView](https://hexdocs.pm/phoenix_live_view/welcome.html) respectively that serve HTML from your server, provided a rich templating language on the frontend, and you were able to achieve client side interactivity **without** writing React code. At this point, I realized we've basically just come full circle... The web began on MPA's, clients written in plain HTML, CSS, JavaScript, that would hit a server responding in new HTML to be rendered using AJAX requests. We **demanded** easier and better client side interactivity and SPA's were born, exacerbating first page load, destroying SEO, but hey, we had a solution to write complex UI's very easily. And now, we're moving _back_ to server side rendering with technologies like Next.js and Remix. I think it was here where I got burned out and wanted to try something else. I was already learning other programming languages too but the itch to target the web didn't stop but thankfully, I landed on a solution which I'm pretty happy with.

### HTMX

At first, I hated it. I didn't understand it. It just felt like moving back to the past. Once I gave it a try though, I was pleasantly surprised. It was refreshing to be able to have client side interactivity _while_ also being server rendered _WITHOUT_ reaching for a bloated "meta-framework/bff" like Next.js that ultimately was trying to solve a problem that never existed in the first place. A simple `hx-get` on my HTML tag fetched data from my server and a simple `hx-post` sent data back to my server for processing. It's so much more concise and straightforward once you start thinking in the HATEOAS (Hypermedia as the Engine of Application State) way. Also, being able to use _any_ language I wanted for my server was a breath of fresh air. I do enjoy writing TypeScript despite it's shortcomings, and it's the language I'm the most proficient in. I've also been impressed at what the [Bun](https://bun.sh/) team is doing and even wrote this website using a Bun server combined with HTMX and a vetted template language called Handlebars.js[^1]. Recently though, I've been learning Rust to sharpen my skill-set, and it feels nice knowing that I could also write a Rust server to achieve the same result I have here. The best part is though, HTMX is not just for simple CRUD functionalities either. You can do websockets, validation, event polling, and so much more. Plus, with HTMX 2 being in the works, it will only get better. I honestly feel like I just have more freedom now, and it also feels like I'm back at my roots as a backend developer when I was writing C, Python, Node servers, etc. but have the tools to write frontends when I need it without needing to learn a bloated and unnecessarily complex frontend framework. If all you need is some simple client side interactivity, not writing a video game targeting the web, or something _super_ interactive like Figma, then HTMX is all you need, but you won't understand it until you try it or see examples (at least that's what it took for myself).

### Conclusion

Am I completely done writing React? Unfortunately not. I have to write it sometimes for my day job despite primarily working in the server code. Companies just require you to know these frameworks to be more marketable as an employee, and until the industry takes a step back like I did, React (and all the other frontend frameworks that spawned off of it) will always be at the top spot and almost a requirement if you want to break into a full-stack developer role. Despite this, for my personal projects, I'm taking a step back and evaluating if I really need to reach for React or if I can keep it simple with HTMX. Again, HTMX is _not_ a React replacement, it's simply a different paradigm for building web applications, and I believe I benefit from it a lot as long as I don't need Figma levels of interactivity on my web app.

I highly recommend reading [this](https://htmx.org/essays/hateoas/) article by HTMX that talks about HATEOAS which compares HTML to JSON and talks about why most applications would benefit from just sending HTML from the server. It really opened my eyes about web development and the amount of over complication I was doing with my projects.

So, the next time you reach for React without a second thought like I did, think about the needs of your app, and ask yourself if you can just **keep it simple**.

[^1]: I actually rewrote this site using the same stack just substituting Bun + Elysia.js for Rust + Axum because my Railway memory usage was too high using Bun...

<figure class="flex justify-center items-center flex-col">
    <img src="/public/images/htmx.png" width="900" alt="htmx-meme"/>
    <figcaption>Credits: <a href="https://htmx.org/essays/#memes">HTMX Memes Section</a></figcaption>
</figure>
